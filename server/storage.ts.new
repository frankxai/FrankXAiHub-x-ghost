import { users, type User, type InsertUser } from "@shared/schema";
import {
  type BlogPost,
  type InsertBlogPost,
  type Resource,
  type InsertResource,
  type AICharacter,
  type InsertAICharacter,
  type MusicSample,
  type InsertMusicSample,
  type ReadingProgress,
  type InsertReadingProgress,
  type Assessment,
  type InsertAssessment
} from "@shared/schema";

// modify the interface with any CRUD methods
// you might need

export interface IStorage {
  // User methods
  getUser(id: number): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;
  
  // Blog posts methods
  getAllBlogPosts(): Promise<BlogPost[]>;
  getBlogPost(id: number): Promise<BlogPost | undefined>;
  createBlogPost(post: InsertBlogPost): Promise<BlogPost>;
  
  // Resources methods
  getAllResources(): Promise<Resource[]>;
  getResource(id: number): Promise<Resource | undefined>;
  createResource(resource: InsertResource): Promise<Resource>;
  deleteResource(id: number): Promise<void>;
  incrementResourceDownloads(id: number): Promise<void>;
  
  // AI Characters methods
  getAllAICharacters(): Promise<AICharacter[]>;
  getAICharacter(id: number): Promise<AICharacter | undefined>;
  createAICharacter(character: InsertAICharacter): Promise<AICharacter>;
  
  // Music Samples methods
  getAllMusicSamples(): Promise<MusicSample[]>;
  getMusicSample(id: number): Promise<MusicSample | undefined>;
  createMusicSample(sample: InsertMusicSample): Promise<MusicSample>;
  
  // Reading Progress methods
  getReadingProgress(userId: number, postId: number): Promise<ReadingProgress | undefined>;
  updateReadingProgress(progress: InsertReadingProgress): Promise<ReadingProgress>;
  
  // Assessment methods
  createAssessment(assessment: InsertAssessment): Promise<Assessment>;
}

// In-memory storage implementation
class MemStorage implements IStorage {
  private users: Map<number, User>;
  private blogPosts: Map<number, BlogPost>;
  private resources: Map<number, Resource>;
  private aiCharacters: Map<number, AICharacter>;
  private musicSamples: Map<number, MusicSample>;
  private readingProgress: Map<string, ReadingProgress>;
  private assessments: Map<number, Assessment>;
  
  // Counters for IDs
  userCurrentId: number;
  blogPostCurrentId: number;
  resourceCurrentId: number;
  aiCharacterCurrentId: number;
  musicSampleCurrentId: number;
  readingProgressCurrentId: number;
  assessmentCurrentId: number;
  
  constructor() {
    this.users = new Map();
    this.blogPosts = new Map();
    this.resources = new Map();
    this.aiCharacters = new Map();
    this.musicSamples = new Map();
    this.readingProgress = new Map();
    this.assessments = new Map();
    
    this.userCurrentId = 0;
    this.blogPostCurrentId = 0;
    this.resourceCurrentId = 0;
    this.aiCharacterCurrentId = 0;
    this.musicSampleCurrentId = 0;
    this.readingProgressCurrentId = 0;
    this.assessmentCurrentId = 0;
    
    // Initialize with sample data
    this.initializeSampleData();
  }
  
  // User methods
  async getUser(id: number): Promise<User | undefined> {
    return this.users.get(id);
  }
  
  async getUserByUsername(username: string): Promise<User | undefined> {
    for (const user of this.users.values()) {
      if (user.username === username) {
        return user;
      }
    }
    return undefined;
  }
  
  async createUser(insertUser: InsertUser): Promise<User> {
    const id = ++this.userCurrentId;
    const user: User = { ...insertUser, id };
    this.users.set(id, user);
    return user;
  }
  
  // Blog posts methods
  async getAllBlogPosts(): Promise<BlogPost[]> {
    return Array.from(this.blogPosts.values());
  }
  
  async getBlogPost(id: number): Promise<BlogPost | undefined> {
    return this.blogPosts.get(id);
  }
  
  async createBlogPost(post: InsertBlogPost): Promise<BlogPost> {
    const id = ++this.blogPostCurrentId;
    const blogPost: BlogPost = { ...post, id };
    this.blogPosts.set(id, blogPost);
    return blogPost;
  }
  
  // Resources methods
  async getAllResources(): Promise<Resource[]> {
    return Array.from(this.resources.values());
  }
  
  async getResource(id: number): Promise<Resource | undefined> {
    return this.resources.get(id);
  }
  
  async createResource(resource: InsertResource): Promise<Resource> {
    const id = ++this.resourceCurrentId;
    const newResource: Resource = { 
      ...resource, 
      id,
      downloads: 0,
    };
    this.resources.set(id, newResource);
    return newResource;
  }
  
  async deleteResource(id: number): Promise<void> {
    this.resources.delete(id);
  }
  
  async incrementResourceDownloads(id: number): Promise<void> {
    const resource = this.resources.get(id);
    if (resource) {
      resource.downloads += 1;
      this.resources.set(id, resource);
    }
  }
  
  // AI Characters methods
  async getAllAICharacters(): Promise<AICharacter[]> {
    return Array.from(this.aiCharacters.values());
  }
  
  async getAICharacter(id: number): Promise<AICharacter | undefined> {
    return this.aiCharacters.get(id);
  }
  
  async createAICharacter(character: InsertAICharacter): Promise<AICharacter> {
    const id = ++this.aiCharacterCurrentId;
    const newCharacter: AICharacter = { ...character, id };
    this.aiCharacters.set(id, newCharacter);
    return newCharacter;
  }
  
  // Music Samples methods
  async getAllMusicSamples(): Promise<MusicSample[]> {
    return Array.from(this.musicSamples.values());
  }
  
  async getMusicSample(id: number): Promise<MusicSample | undefined> {
    return this.musicSamples.get(id);
  }
  
  async createMusicSample(sample: InsertMusicSample): Promise<MusicSample> {
    const id = ++this.musicSampleCurrentId;
    const newSample: MusicSample = { ...sample, id };
    this.musicSamples.set(id, newSample);
    return newSample;
  }
  
  // Reading Progress methods
  async getReadingProgress(userId: number, postId: number): Promise<ReadingProgress | undefined> {
    return this.readingProgress.get(`${userId}-${postId}`);
  }
  
  async updateReadingProgress(progress: InsertReadingProgress): Promise<ReadingProgress> {
    const key = `${progress.userId}-${progress.postId}`;
    const existing = this.readingProgress.get(key);
    
    if (existing) {
      existing.progress = progress.progress;
      this.readingProgress.set(key, existing);
      return existing;
    } else {
      const id = ++this.readingProgressCurrentId;
      const newProgress: ReadingProgress = { ...progress, id };
      this.readingProgress.set(key, newProgress);
      return newProgress;
    }
  }
  
  // Assessment methods
  async createAssessment(assessment: InsertAssessment): Promise<Assessment> {
    const id = ++this.assessmentCurrentId;
    const newAssessment: Assessment = { 
      ...assessment,
      id,
      createdAt: new Date(),
    };
    this.assessments.set(id, newAssessment);
    return newAssessment;
  }
  
  // Initialize with sample data
  private initializeSampleData() {
    // Create sample blog posts
    const blogPosts = [
      {
        id: 1,
        title: "Building an AI Center of Excellence",
        excerpt: "A strategic framework for implementing enterprise-wide AI capabilities.",
        content: "# Building an AI Center of Excellence\n\nA strategic framework for implementing enterprise-wide AI capabilities that delivers measurable ROI and drives competitive advantage.\n\n## Executive Summary\n\nThe AI Center of Excellence (AICoE) serves as the central nervous system for an organization's artificial intelligence initiatives. It brings together expertise, resources, and governance to accelerate adoption while ensuring responsible implementation aligned with strategic objectives.\n\nThis framework outlines the key components necessary for establishing an effective AICoE, based on successful implementations across industries and organizational sizes.\n\n## Core Components\n\n### 1. Strategic Alignment\n\nThe AICoE must connect directly to core business objectives:\n\n- **Value Identification**: Mapping AI opportunities to strategic priorities\n- **Business Case Development**: Establishing clear ROI metrics and success criteria\n- **Stakeholder Alignment**: Ensuring executive sponsorship and cross-functional buy-in\n\n### 2. Talent & Expertise\n\nBuilding the right team is critical:\n\n- **Interdisciplinary Skills**: Technical expertise balanced with domain knowledge and change management capabilities\n- **Hub-and-Spoke Model**: Core team of specialists supporting distributed AI champions\n- **Learning Culture**: Continuous upskilling and knowledge sharing\n\n### 3. Technology Infrastructure\n\nCreating the foundation for scalable AI:\n\n- **Data Architecture**: Accessible, high-quality data pipelines\n- **Compute Resources**: Appropriate processing capabilities for model development\n- **Development Environment**: Standardized tools and platforms for consistent delivery\n\n### 4. Governance Framework\n\nEnsuring responsible and effective implementation:\n\n- **Ethical Guidelines**: Principles for responsible AI development and usage\n- **Review Process**: Systematic evaluation of AI initiatives\n- **Risk Management**: Controls for technical, operational, and reputational risks\n\n### 5. Delivery Methodology\n\nOperationalizing AI at scale:\n\n- **Project Selection**: Prioritization framework for maximum impact\n- **Agile Processes**: Iterative development with continuous feedback\n- **Production Integration**: Standards for deploying and monitoring AI systems\n\n## Implementation Roadmap\n\n### Phase 1: Foundation (3-6 months)\n- Establish baseline capabilities\n- Deliver 2-3 high-impact pilots\n- Build initial operational processes\n\n### Phase 2: Acceleration (6-12 months)\n- Scale successful use cases\n- Formalize governance structure\n- Expand technical capabilities\n\n### Phase 3: Transformation (12+ months)\n- Embed AI into core processes\n- Implement advanced capabilities\n- Drive innovation at enterprise scale\n\n## Success Metrics\n\nEffective AICoEs measure performance across multiple dimensions:\n\n- **Financial Impact**: Direct ROI from implemented solutions\n- **Operational Metrics**: Efficiency and quality improvements\n- **Capability Building**: Skills development and knowledge transfer\n- **Innovation Indicators**: New products/services enabled\n\n## Conclusion\n\nCreating an AI Center of Excellence requires thoughtful planning and organizational commitment, but the potential rewards are substantial. Organizations that successfully implement this framework can expect accelerated AI adoption, improved ROI on technology investments, and sustainable competitive advantage.",
        imageUrl: "https://images.unsplash.com/photo-1507146153580-69a1fe6d8aa1",
        category: "Strategy",
        authorName: "Frank Venture",
        publishedAt: new Date("2025-02-15"),
        readTime: 8,
      },
      {
        id: 2,
        title: "The ROI of Enterprise AI Implementation",
        excerpt: "How to measure and maximize the return on investment from artificial intelligence initiatives.",
        content: "# The ROI of Enterprise AI Implementation\n\n## Introduction: The Strategic Value Proposition\n\nArtificial intelligence represents one of the most significant opportunities for enterprise value creation in the modern business landscape. However, justifying AI investments requires a robust framework for measuring return on investment that extends beyond traditional financial metrics.\n\nThis guide explores how organizations can develop a comprehensive ROI model for AI initiatives, accounting for both direct financial impacts and broader transformational benefits.\n\n## Quantifying AI Value: A Multi-Dimensional Approach\n\nEffective AI ROI measurement requires consideration of four key dimensions:\n\n1. **Direct Cost Reduction**: Labor savings, process efficiency, and resource optimization\n2. **Revenue Enhancement**: Increased sales, customer retention, and new business models\n3. **Risk Mitigation**: Reduced errors, fraud prevention, and compliance improvements\n4. **Strategic Positioning**: Competitive advantage, innovation capacity, and organizational capabilities\n\n## ROI Benchmarks by Function\n\n### Customer Service\n\n**Implementation costs:**\n- LLM customization and integration: $150,000-$500,000\n- Ongoing model updates and maintenance: $50,000-$200,000/year\n\n**Value metrics:**\n- Average handle time reduction: 25-40%\n- First contact resolution improvement: 15-30%\n- Agent productivity increase: 20-35%\n- Training time reduction: 30-50%\n\n**Sample ROI calculation:**\nFor a customer service operation with 100 agents at $50,000 fully-loaded cost per agent:\n- 30% productivity improvement = 30 FTE equivalent = $1.5M annual savings\n- Improved customer satisfaction and retention = $500K-$1M additional value\n- Total annual value: $2-2.5M against $250K-$700K implementation and annual costs\n\n### Marketing and Content Creation\n\n**Implementation costs:**\n- Content-specific LLM fine-tuning: $100,000-$300,000\n- Integration with content management systems: $50,000-$150,000\n- Ongoing optimization: $40,000-$120,000/year\n\n**Value metrics:**\n- Content production volume increase: 3-5x\n- Content creation time reduction: 50-70%\n- A/B testing efficiency improvement: 40-60%\n- Campaign launch acceleration: 30-50%\n\n**Sample ROI calculation:**\nFor a marketing department spending $2M annually on content creation:\n- 60% efficiency improvement = $1.2M cost avoidance\n- Faster campaign execution = 20% increased campaign effectiveness = $400K additional revenue\n- Total annual value: $1.6M against $150K-$450K implementation and annual costs\n\n## Critical Success Factors for Maximizing LLM ROI\n\nBeyond the numbers, several organizational factors significantly impact the realized ROI from enterprise LLM implementations:\n\n### 1. Clear Use Case Prioritization\n\nOrganizations that begin with high-impact, well-defined use cases achieve faster payback periods. The most successful approach involves:\n\n- Identifying tasks with high volume, clear patterns, and significant time investment\n- Calculating detailed baseline metrics before implementation\n- Setting specific improvement targets tied to business outcomes\n\n### 2. Thoughtful Human-AI Collaboration Design\n\nThe highest ROI comes from implementations that optimize the division of labor between humans and AI:\n\n- Assign repetitive, pattern-based work to LLMs\n- Reserve judgment, creativity, and stakeholder interaction for humans\n- Create clear escalation paths for complex cases\n- Implement feedback loops for continuous improvement\n\n## Implementation Roadmap: A Phased Approach to Value Realization\n\nMaximizing ROI from enterprise LLMs is best achieved through a methodical, phased approach that balances quick wins with long-term value creation:\n\n### Phase 1: Foundation (3-6 months)\n\n- Establish baseline metrics for target processes\n- Implement 2-3 high-impact, contained use cases\n- Develop initial governance and usage guidelines\n- Prioritize integration with key workflow systems\n\n### Phase 2: Expansion (6-12 months)\n\n- Scale successful pilots across departments\n- Extend capabilities based on user adoption and feedback\n- Implement more sophisticated use cases requiring deeper customization\n- Develop internal expertise for ongoing optimization\n\n## Conclusion: The Strategic Imperative of Enterprise LLMs\n\nWhile ROI calculations provide necessary justification for LLM investments, forward-looking organizations recognize that these technologies represent more than incremental efficiency gains. Enterprise LLMs are becoming fundamental infrastructure for competitive advantage in the AI era.",
        imageUrl: "https://images.unsplash.com/photo-1676299081847-3e95d5848b6b",
        category: "Technology",
        authorName: "Michael Chen",
        publishedAt: new Date("2025-02-08"),
        readTime: 9,
      },
      {
        id: 3,
        title: "Practical Guide to AI Model Selection",
        excerpt: "How to navigate the complex landscape of AI models and choose the right option for your specific use case.",
        content: "# Practical Guide to AI Model Selection\n\n## Introduction\n\nWith the rapid proliferation of AI models, selecting the optimal option for a specific business need has become increasingly complex. This guide provides a structured approach to model selection that balances performance, cost, and strategic considerations.\n\n## Part 1: Defining Your Requirements\n\nBefore evaluating specific models, clarify these foundational elements:\n\n### Use Case Characterization\n\n- **Task Type**: Classification, generation, prediction, etc.\n- **Domain Specificity**: General vs. domain-specific requirements\n- **Performance Priorities**: Speed, accuracy, cost, or flexibility\n- **Integration Context**: Standalone vs. workflow integration\n\n### Data Considerations\n\n- **Available Data**: Volume, quality, and representativeness \n- **Privacy Requirements**: PII handling and security needs\n- **Update Frequency**: Static vs. dynamic data environments\n- **Multimodal Needs**: Text, images, audio, etc.\n\n### Deployment Context\n\n- **Latency Requirements**: Real-time vs. batch processing\n- **Compute Resources**: Available infrastructure\n- **Regulatory Constraints**: Compliance and governance\n- **Operational Model**: Cloud, on-premises, or hybrid\n\n## Part 2: Model Evaluation Framework\n\n### Large Language Models (LLMs)\n\n| Model Family | Strengths | Limitations | Best For |\n|--------------|-----------|------------|----------|\n| GPT-4 (OpenAI) | Exceptional general reasoning, code understanding, and instruction following | Higher cost, latency constraints | Complex reasoning tasks, multi-step instructions, creative content |\n| Claude (Anthropic) | Strong reasoning, longer context window, thoughtful safeguards | Less technical/code capability than GPT-4 | Long-document analysis, nuanced content generation with safety focus |\n| Llama 2 (Meta) | Open weights, self-hosted option, strong performance/cost ratio | Requires technical expertise to deploy | Cost-sensitive applications, privacy-focused use cases |\n| Mistral | Excellent performance/size ratio, efficient inference | Newer with less ecosystem support | Embedded applications, resource-constrained environments |\n| PaLM 2 (Google) | Strong multilingual capabilities, broad knowledge | API limitations, less specialized tooling | Global applications, multilingual needs |\n\n### Specialized Models\n\nFor domain-specific needs, consider:\n\n- **Embedding Models**: Ada (OpenAI), BGE (BAAI), BERT variants\n- **Vision-Language Models**: GPT-4V, Claude Opus, Gemini\n- **Domain-Specific Models**: Healthcare, legal, financial\n\n## Part 3: Decision Matrix Methodology\n\nWhen evaluating multiple models, use this weighted scoring system:\n\n1. **Identify key criteria**: Performance, cost, ease of implementation, etc.\n2. **Weight criteria** based on importance (1-10)\n3. **Score each model** against criteria (1-5)\n4. **Calculate weighted scores** (weight Ã— score)\n5. **Sum totals** for comparison\n\n## Part 4: Implementation Strategy\n\nOnce you've selected your model, consider these implementation best practices:\n\n### 1. Pilot Structure\n\n- Start with a limited scope\n- Establish clear metrics\n- Plan for iteration\n\n### 2. Evaluation Process\n\n- Define a systematic testing approach\n- Include representative data\n- Compare against baseline methods\n\n### 3. Deployment Considerations\n\n- Monitoring infrastructure\n- Fallback mechanisms\n- Feedback collection\n\n## Conclusion\n\nModel selection is not a one-time decision but an ongoing process. As AI technology evolves rapidly, build flexibility into your approach to take advantage of new capabilities as they emerge.\n\nThe best model is rarely the most advanced or expensive option, but rather the one that best fits your specific requirements, constraints, and objectives.",
        imageUrl: "https://images.unsplash.com/photo-1680987082559-6b0f39a35412",
        category: "Technical",
        authorName: "Amanda Rodriguez",
        publishedAt: new Date("2025-02-03"),
        readTime: 12,
      }
    ];
    
    for (const post of blogPosts) {
      this.blogPosts.set(post.id, post);
      this.blogPostCurrentId = Math.max(this.blogPostCurrentId, post.id);
    }
    
    // Create sample resources
    const resources = [
      {
        id: 1,
        title: "AI Governance Framework",
        description: "A comprehensive guide to establishing ethical AI governance in enterprise environments",
        type: "pdf",
        icon: "file-text",
        link: "https://example.com/ai-governance.pdf",
        isPremium: false,
        price: null,
        affiliateCode: null,
        downloads: 245,
      },
      {
        id: 2,
        title: "Enterprise LLM Implementation Toolkit",
        description: "Templates, checklists, and guidelines for implementing large language models at enterprise scale",
        type: "zip",
        icon: "archive",
        link: "https://example.com/llm-toolkit.zip",
        isPremium: true,
        price: "$199",
        affiliateCode: "FRANK20",
        downloads: 187,
      },
      {
        id: 3,
        title: "AI ROI Calculator",
        description: "Interactive tool for estimating return on investment for AI initiatives",
        type: "excel",
        icon: "calculator",
        link: "https://example.com/ai-roi-calculator.xlsx",
        isPremium: false,
        price: null,
        affiliateCode: null,
        downloads: 312,
      },
      {
        id: 4,
        title: "AI Strategy Playbook",
        description: "Strategic frameworks for developing and implementing effective AI strategies",
        type: "pdf",
        icon: "file-text",
        link: "https://example.com/ai-strategy-playbook.pdf",
        isPremium: true,
        price: "$299",
        affiliateCode: "FRANK25",
        downloads: 156,
      }
    ];
    
    for (const resource of resources) {
      this.resources.set(resource.id, resource);
      this.resourceCurrentId = Math.max(this.resourceCurrentId, resource.id);
    }
    
    // Create sample AI characters
    const aiCharacters = [
      {
        id: 1,
        name: "Strategic Advisor",
        description: "AI business strategy consultant specializing in enterprise AI transformation",
        persona: "I am a strategic AI consultant with 20+ years of experience guiding Fortune 500 companies through digital transformation. My approach is analytical, business-focused, and results-oriented. I specialize in identifying high-ROI AI use cases and creating practical implementation roadmaps.",
        avatarUrl: "https://images.unsplash.com/photo-1568602471122-7832951cc4c5",
        capabilities: ["Strategy Development", "ROI Analysis", "Implementation Planning"],
        model: "gpt-4",
        provider: "openai",
      },
      {
        id: 2,
        name: "Technical Architect",
        description: "AI systems architect specializing in enterprise LLM implementation",
        persona: "I am an experienced AI systems architect who has designed and deployed large-scale machine learning systems across various industries. I provide detailed technical guidance on model selection, infrastructure requirements, and system integration. My communication style is precise, thorough, and technically focused.",
        avatarUrl: "https://images.unsplash.com/photo-1580489944761-15a19d654956",
        capabilities: ["Architecture Design", "Model Selection", "Technical Implementation"],
        model: "claude-instant",
        provider: "anthropic",
      },
      {
        id: 3,
        name: "Change Management Coach",
        description: "Specialist in organizational transformation for AI initiatives",
        persona: "I am a change management consultant focused on the human side of AI implementation. I help organizations prepare their teams for AI adoption, addressing concerns, building enthusiasm, and creating effective training programs. My style is empathetic, practical, and focused on creating sustainable change.",
        avatarUrl: "https://images.unsplash.com/photo-1573497019940-1c28c88b4f3e",
        capabilities: ["Change Leadership", "Training Program Design", "Stakeholder Management"],
        model: "gpt-4",
        provider: "openai",
      }
    ];
    
    for (const character of aiCharacters) {
      this.aiCharacters.set(character.id, character);
      this.aiCharacterCurrentId = Math.max(this.aiCharacterCurrentId, character.id);
    }
    
    // Create sample music samples
    const musicSamples = [
      {
        id: 1,
        title: "AI Symphony No. 1",
        description: "A classical composition created using advanced AI music generation",
        audioUrl: "https://example.com/ai-symphony-1.mp3",
        imageUrl: "https://images.unsplash.com/photo-1507838153414-b4b713384a76",
        type: "classical",
        duration: 180,
        isVideo: false,
        videoUrl: null,
      },
      {
        id: 2,
        title: "Neural Beats",
        description: "Electronic music generated by a neural network trained on dance music",
        audioUrl: "https://example.com/neural-beats.mp3",
        imageUrl: "https://images.unsplash.com/photo-1571330735066-03aaa9429d89",
        type: "electronic",
        duration: 210,
        isVideo: true,
        videoUrl: "https://www.youtube.com/embed/dQw4w9WgXcQ",
      }
    ];
    
    for (const sample of musicSamples) {
      this.musicSamples.set(sample.id, sample);
      this.musicSampleCurrentId = Math.max(this.musicSampleCurrentId, sample.id);
    }
    
    // Create a sample user
    const user = {
      id: 1,
      username: "admin",
      password: "admin123", // In a real app, this would be hashed
    };
    
    this.users.set(user.id, user);
    this.userCurrentId = Math.max(this.userCurrentId, user.id);
  }
}

export const storage = new MemStorage();